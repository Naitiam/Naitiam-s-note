# 链表

1)  链表是以节点的方式来存储，是**链式存储**
2)  每个节点包含data域，next域：指向下一个节点.
3)  各个节点**不一定连续存储**.
4)  链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定

## 单链表



## 双链表

图解



完整代码

```java
package stu;

public class DoubleLinked {
    public static void main(String[] args) {
        Integer[] list = {1,2,3};
        DLinkListClass<Integer> d = new DLinkListClass<Integer>();
//        d.CreateListF(list);
        d.CreateListR(list);
        d.Insert(3,4);
        d.Delete(3);
        d.list();
        System.out.println();
        System.out.println("当前双链表的长度是"+d.size());
    }
}

class DLinkListClass<E>{
    DLinkNode<E> dhead;

    public DLinkNode<E> getDhead() {
        return dhead;
    }

    public DLinkListClass(){
        dhead = new DLinkNode<E>();
        dhead.prior = null;
        dhead.next = null;
    }
    //基本运算方法
    //头插法建表
    public void CreateListF(E[] a){
        DLinkNode<E> temp ;//定义临时对象
        for(int i = 0;i<a.length;i++){
            temp = new DLinkNode<E>(a[i]);//实例化对象并传值
            temp.next = dhead.next;
            if(dhead.next != null){
                dhead.next.prior = temp;//下一个节点不是空，那么下一个指针的节点指回当前节点
            }
            dhead.next = temp;
            temp.prior = dhead;
        }
    }
    //尾插法建表
    public void CreateListR(E[] a){
        DLinkNode<E> temp,h;
        h = dhead;
        for(int i = 0;i<a.length;i++){
            temp = new DLinkNode<E>(a[i]);//实例化对象并传值
            h.next = temp;
            temp.prior = h;
            h = h.next;
        }
        h.next = null;
    }

    //序号为i的后面插入节点
    public void Insert(Integer i,E e){
        DLinkNode h = dhead;
        DLinkNode d = new DLinkNode(e);
        boolean flag = false;
        while (true){
            if(h.data == i){
                //插入节点,判断该节点是否是是最后一个节点
                if (h.next==null){
                    //该节点为最后一个节点
                    h.next = d;
                    d.prior = h;
                    break;
                }else {
                    d.next = h.next;
                    h.next.prior = d;
                    d.prior = h;
                    h.next = d;
                    break;
                }
            }
            if(h.next == null){
                break;
            }
            h = h.next;
        }
    }

    //删除序号为i的节点
    public void Delete(Integer i){
        DLinkNode h = dhead;
        boolean flag = false;
        while (true){
            if(h.data == i){
                //删除节点,判断该节点是否是是最后一个节点
                if (h.next==null){
                    h.prior.next = null;
                }else {
                    h.prior.next = h.next;
                    h.next.prior = h.prior;
                    break;
                }
            }
            if(h.next == null){
                break;
            }
            h = h.next;
        }
    }

    //返回节点长度
    public int size(){
        DLinkNode h = dhead;
        int lenght = 0;
        while (true){
            if(h.next == null){
                break;
            }
            lenght++;
            h = h.next;
        }
        return lenght;
    }

    //遍历当前节点
    public void list(){
        if (dhead.next == null) {
            System.out.println("该链表为空");
            return;
        }
        // 因为头节点，不能动，因此我们需要一个辅助变量来遍历
        DLinkNode temp = dhead.next;
        while (true) {
            // 判断是否到链表最后
            if (temp == null) {
                break;
            }
            // 输出节点的信息
            System.out.print(temp.data+" ");
            // 将temp后移， 一定小心
            temp = temp.next;
        }
    }

}
class DLinkNode<E>{
    E data;
    DLinkNode<E> prior;
    DLinkNode<E> next;
    public DLinkNode(){
        prior = null;
        next = null;
    }
    public DLinkNode(E d){
        data = d;
        prior = null;
        next = null;
    }

}
```

## 循环链表

### 约瑟夫



